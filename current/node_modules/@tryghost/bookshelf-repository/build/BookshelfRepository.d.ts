import { Knex } from 'knex';
type Entity<T> = {
    id: T;
    deleted: boolean;
};
type Order<T> = {
    field: keyof T;
    direction: 'asc' | 'desc';
};
export type ModelClass<T> = {
    destroy: (data: {
        id: T;
    }) => Promise<void>;
    findOne: (data: {
        id: T;
    }, options?: {
        require?: boolean;
    }) => Promise<ModelInstance<T> | null>;
    add: (data: object) => Promise<ModelInstance<T>>;
    getFilteredCollection: (options: {
        filter?: string;
        mongoTransformer?: unknown;
    }) => {
        count(): Promise<number>;
        query: (f?: (q: Knex.QueryBuilder) => void) => Knex.QueryBuilder;
        fetchAll: () => Promise<ModelInstance<T>[]>;
    };
};
export type ModelInstance<T> = {
    id: T;
    get(field: string): unknown;
    set(data: object | string, value?: unknown): void;
    save(properties: object, options?: {
        autoRefresh?: boolean;
        method?: 'update' | 'insert';
    }): Promise<ModelInstance<T>>;
};
export type OrderOption<T extends Entity<any> = any> = Order<T>[];
export declare abstract class BookshelfRepository<IDType, T extends Entity<IDType>> {
    #private;
    protected Model: ModelClass<IDType>;
    constructor(Model: ModelClass<IDType>);
    protected abstract toPrimitive(entity: T): object;
    protected abstract modelToEntity(model: ModelInstance<IDType>): Promise<T | null> | T | null;
    protected abstract getFieldToColumnMap(): Record<keyof T, string>;
    save(entity: T): Promise<void>;
    getById(id: IDType): Promise<T | null>;
    getAll({ filter, order }?: {
        filter?: string;
        order?: OrderOption<T>;
    }): Promise<T[]>;
    getPage({ filter, order, page, limit }: {
        filter?: string;
        order?: OrderOption<T>;
        page: number;
        limit: number;
    }): Promise<T[]>;
    getCount({ filter }?: {
        filter?: string;
    }): Promise<number>;
    getGroupedCount<K extends keyof T>({ filter, groupBy }: {
        filter?: string;
        groupBy: K;
    }): Promise<({
        count: number;
    } & Record<K, T[K]>)[]>;
}
export {};
